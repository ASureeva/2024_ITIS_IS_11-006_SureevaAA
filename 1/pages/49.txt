             -    Википедия                                             -   Материал из Википедии   свободной энциклопедии Текущая версия страницы пока не проверялась опытными участниками и может значительно отличаться от версии  проверенной    мая      года  проверки требует   правка  Текущая версия страницы пока не проверялась опытными участниками и может значительно отличаться от версии  проверенной    мая      года  проверки требует   правка       Перейти к навигации Перейти к поиску          -   Класс языка  объектно-ориентированный  мультипарадигмальный  рефлексивно-ориентированный   Появился в         Автор  Бред Кокс       Расширение файлов              или      Выпуск           Система типов  слабая  статическая   динамическая   Основные реализации                                          Испытал влияние                 Повлиял на                 -           Сайт                             Медиафайлы на Викискладе           -    компилируемый объектно-ориентированный язык программирования  используемый корпорацией        построенный на основе языка Си и парадигм            В частности  объектная модель построена в стиле             то есть объектам посылаются сообщения  Язык          -  является надмножеством языка Си  поэтому Си-код полностью понятен компилятору          -   Компилятор          -  входит в     и доступен на большинстве основных платформ  Язык используется в первую очередь для               и           реализаций объектно-ориентированного интерфейса           Также язык используется для                     Содержание    История   Синтаксис языка   Создание новых классов   Как работает механизм сообщений   Протоколы   Обработка исключений   Синхронизация   Создание и уничтожение объектов   Управление памятью      Базовые принципы     Базовые принципы на практике                -пул     Копирование объектов      Категории                  и          -             Разное    См  также    Примечания    Литература    Ссылки   История править   править код  В начале     -х годов было популярно структурное программирование  позволяющее разделить алгоритм на небольшие блоки  Однако  с ростом сложности задач  структурное программирование приводило к снижению качества кода  Приходилось писать всё больше функций  которые очень редко могли использоваться в других программах  Многие программисты увидели в объектно-ориентированном программировании потенциальное решение возникшей проблемы  С одной стороны            использовали почти все более-менее сложные системы  С другой   использование виртуальных машин повышало требования к ресурсам           -  был создан Брэдом Коксом в начале     -х в его компании            Он пытался решить проблему повторного использования кода  Целью Кокса было создание языка  поддерживающего концепцию              подразумевающей возможность собирать программы из готовых компонентов  объектов   подобно тому как сложные электронные устройства могут быть собраны из набора готовых интегральных микросхем  При этом язык должен быть простым и основанным на языке С  чтобы облегчить переход разработчиков на него  Одной из целей было также создание модели  в которой сами классы являются полноценными объектами  поддерживалась бы интроспекция и динамическая обработка сообщений           -  является расширением С  любая программа на С является программой на          -   Одной из отличительных черт          -  является динамичность  решения  обычно принимаемые на этапе компиляции  здесь откладываются до этапа выполнения           -           -        -язык  в то время как               -          в          -  вызовы метода интерпретируются не как вызов функции  хотя к этому обычно все сводится   а как посылка сообщения  с именем и аргументами  объекту  подобно тому  как это происходит в            Любому объекту можно послать любое сообщение  Объект может вместо обработки сообщения переслать его другому объекту для обработки  делегирование   в частности  так можно реализовать распределённые  то есть находящиеся в различных адресных пространствах и даже на разных компьютерах  объекты  Привязка сообщения к соответствующей функции происходит на этапе выполнения  Язык          -  поддерживает работу с метаинформацией   так  на этапе выполнения можно узнать класс объекта  список его методов  с типами передаваемых аргументов  и         -переменных  проверить  является ли класс потомком заданного и поддерживает ли он заданный протокол и т  п  В языке есть поддержка протоколов  понятия интерфейса объекта и протокола четко разделены   Поддерживается наследование  не множественное   для протоколов поддерживается множественное наследование  Объект может быть унаследован от другого объекта и сразу нескольких протоколов  хотя это скорее не наследование протокола  а его поддержка   На данный момент язык          -  поддерживается компиляторами       и      под управлением         используется в составе       или          Некоторые функции языка перенесены в        -библиотеку и сильно зависят от неё  Вместе с компилятором     поставляется минимальный вариант такой библиотеки  Также можно свободно скачать        -библиотеку компании                         -           Эти две        -библиотеки похожи  основные отличия в именах методов   Далее примеры будут ориентироваться на        -библиотеку         Синтаксис языка править   править код  В языке          -  для обозначения объектов используется специальный тип     это аналог типа        в        Переменная типа    фактически является указателем на произвольный объект  Для обозначения нулевого указателя на объект используется константа               При этом вместо    можно использовать и более привычное обозначение с явным указанием класса  В частности последнее позволяет компилятору осуществлять некоторую проверку поддержки сообщения объектами   если компилятор из типа переменной не может сделать вывод о поддержке объектом данного сообщения  то он выдаст предупреждение  Тем самым язык поддерживает проверку типов  но в нестрогой форме  то есть найденные несоответствия возвращаются как предупреждения  а не ошибки   Для посылки сообщений используется следующий синтаксис                           В этой конструкции          является указателем на объект  а           именем метода  В отличие от языка      посылка сообщения     у является законной операцией  всегда возвращающей нулевое значение        Сообщение может также содержать параметры                                      В этом примере именем метода  сообщения  является              Обратите внимание  что каждому передаваемому аргументу соответствует ровно одно двоеточие  При этом в приведенном примере первый аргумент имеет метку  текст перед двоеточием   а второй   нет  Язык          -  позволяет снабжать метками каждый аргумент  что заметно повышает читаемость кода и снижает вероятность передачи неправильного параметра  Именно такой стиль принят большинством разработчиков                                           В этом примере в качестве имени сообщения выступает                    Также поддерживается возможность передачи произвольного количества аргументов в сообщении                                                          Как и функции  сообщения могут возвращать значения  при этом в отличие от языка С  типом значения  возвращаемым по умолчанию  является                                      Результат одного сообщения можно сразу же использовать в другом сообщении                                            Как уже говорилось  в          -  классы сами являются объектами  Основной задачей таких объектов  называемых                является создание экземпляров данного класса  паттерн                     При этом само имя класса играет двойную роль   с одной стороны оно выступает как тип данных  то есть он может быть использован для описания указателей на объекты данного класса   А с другой стороны имя класса может выступать в качестве объекта  которому посылается сообщение  в сообщениях имя класса может принимать участие только как                                                      В языке          -  нет встроенного типа для булевских величин  поэтому обычно такой тип вводится искусственно  Далее для логических величин будет использоваться тип      с возможными значениями     и     как это делается в операционных системах                      Первым достаточно серьёзным применением языка          -  было его использование в операционной системе           Для этой системы было написано большое количество различных классов на          -   многие из которых до сих пор используются в           Имена всех этих классов начинаются с префикса     обозначающего свою принадлежность к операционной системе           Сейчас они входят в библиотеку             на которой строятся приложения для      и      С одним из них              мы столкнемся в данной статье  Этот класс служит для работы со строками  при этом в качестве внутреннего представления символов используется Юникод   Компилятор поддерживает данный тип  автоматически переводя конструкции вида              в указатель на объект класса           содержащий данную строку  точнее его подкласса  соответствующего константным строкам    Свойства Допустим  в классе         существует         -переменная                                                                Для доступа к ней извне лучше всего воспользоваться свойствами  которые появились в          -       Для объявления свойств используется ключевое слово                                                 В скобках перечисляются атрибуты доступа к         -переменной  Атрибуты разделяются на   основные группы  Имена акцессора и мутатора                     используется для задания имени функции  используемой для извлечения значения         -переменной                     используется для задания имени функции  используемой для установки значения         -переменной  Ограничение чтения записи              у свойства есть как акцессор  так и мутатор  Является атрибутом по умолчанию             у свойства есть только акцессор  Эти атрибуты взаимоисключают друг друга  И последняя группа атрибуты мутатора            для задания нового значения используется оператор присваивания  Используется только для    -типов либо для объектов  которыми мы не владеем           указывает на то  что для объекта  используемого в качестве нового значения         -переменной  управление памятью происходит вручную  не забываем потом освободить память          указывает на то  что для присваивания будет использована копия переданного объекта         аналог        при применении режима автоматического подсчёта ссылок       должен поддерживаться компилятором           аналог        при применении режима автоматического подсчёта ссылок       должен поддерживаться компилятором  При работе под    никакой разницы между использованием                      нет  Для создания кода свойств  в соответствии с тем  как они описаны в объявлении  можно воспользоваться автогенерацией кода                      Автоматически созданный код   не всегда подходящее решение и может потребоваться создание методов доступа к         -переменным вручную  Язык часто критикуют за перегруженный  по сравнению с другими языками  синтаксис  Однако при этом нередко отмечается его более высокая читаемость   Создание новых классов править   править код  Все ключевые слова языка          -   отсутствующие в С  начинаются с символа    Как и в      описание класса и его реализация разделены  обычно описание помещается в заголовочные файлы с расширением    а реализации   в файлы с расширением     Ниже приводится общая структура описания нового класса                                                                                                       В версии         от       все классы имеют общего предка   класс           содержащий целый ряд важных методов  Описание переменных ничем не отличается от описания переменных в структурах в языке С  Если у вас не        то скорее всего вместо          вам потребуется                                                                                                                                                     Описания же методов заметно отличаются от принятых в     и очень сильно похожи на описания методов в языке            Каждое описание начинается со знака плюс или минус  Знак плюс обозначает  что данный метод является методом класса  то есть его можно посылать только              у  а не экземплярам данного класса   Фактически методы класса являются аналогами статических методов в классах в языке      Знак минус служит для обозначения методов объектов   экземпляров данного класса  Обратите внимание  что в          -  все методы являются виртуальными  то есть могут быть переопределены  Ниже приводятся описания возможных методов для класса                                                                                                                                               -                 -                -                 -               -                                    -                                      -                                                  Обратите внимание  что имя метода может совпадать с именем         -переменной данного класса  например        и          Тип возвращаемого методом значения указывается в круглых скобках сразу же после знака плюс или минус  но перед названием метода   Если тип не указан  то считается  что возвращается значение типа     Далее идет имя метода  где после каждого двоеточия задается тип аргумента  в круглых скобках  и сам аргумент  Язык          -  позволяет для аргументов метода задавать также один из следующих описателей                                  и        Данные описатели служат для задания направления передачи данных и способа передачи  Их наличие заметно упрощает реализацию и работу с распределенными объектами  которые были реализованы в операционной системе          к началу   -х годов прошлого века   Метод  принимающий произвольное количество параметров  может быть описан следующим образом   -                               Для подключения заголовочного файла в          -  вместо директивы          используется директива          аналогичная           но гарантирующая  что данный файл будет подключен всего один раз  В ряде случаев возникает необходимость в объявлении того  что данное имя является именем класса  но без явного его описания  такая необходимость возникает при описании двух классов  каждый из которых ссылается на другой класс   В этом случае можно воспользоваться директивой         объявляющей  что следующие за ней имена являются именами классов                              Реализация методов класса выглядит следующим образом                                                                                       Ниже приводится пример реализации методов класса       описанного выше                                                                                                                                                                                            -                                     -                                       -                                                           -                                                             -                                                                 -                                                                                Как видно из примера выше  в методах доступны все         -переменные  Однако  как и в      есть возможность управлять видимостью переменных  видимостью методов управлять нельзя  при помощи директив                      и          действующих полностью аналогично языку                                                                                                                                                             При этом к        переменным класса можно обращаться непосредственно  используя оператор -   например        -               Как работает механизм сообщений править   править код  Компилятор переводит каждую посылку сообщения  то есть конструкцию вида              в вызов функции               Эта функция в качестве своего первого параметра принимает указатель на объект-получатель сообщения  в качестве второго параметра выступает т  н  селектор  служащий для идентификации посылаемого сообщения  Если в сообщении присутствуют аргументы  то они также передаются              как третий  четвёртый и т  д  параметры  Каждый объект          -  содержит в себе атрибут       указатель на              для данного объекта               автоматически создается компилятором и существует как один экземпляр  на который через     ссылаются все экземпляры данного класса  Каждый              обязательно содержит в себе указатель на              для родительского класса              и                 Последняя представляет собой словарь  сопоставляющий селекторам сообщений фактические адреса реализующих их методов  функций   Таким образом  функция              ищет метод с данным селектором в                для данного объекта  Если его там нет  то поиск продолжается в                для его родительского класса и т  д  Если метод  то есть соответствующая ему функция  находится  то осуществляется его вызов с передачей всех необходимых аргументов  В противном случае объекту дается последний шанс обработать сообщение перед вызовом исключения   селектор сообщения вместе с параметрами  заворачивается  в специальный объект типа              и объекту посылается сообщение                     где в качестве параметра выступает объект класса               Если объект поддерживает                     то он может либо сам обработать посылаемое сообщение  либо переслать другому объекту для обработки   -                                                                                                                                                                                                                         Для ускорения поиска сообщений по                используется кэширование  позволяющее заметно снизить затраты на пересылку сообщений  Также облегчает поиск метода по таблицам использование так называемых селекторов вместо обычных имен  Обычно селектор представляет собой   -битовую величину  позволяющую однозначно идентифицировать метод  Тип селектора обозначается как     и существует ряд функций и конструкций  позволяющих осуществлять преобразование имени в селектор и обратно  Так для получения селектора сообщения непосредственно по имени служит конструкция                                                                                                     Для получения селектора по строке символов  на этапе выполнения  и перевода селектора в строку служат функции                      и                                                                                                                                                        Мощная поддержка метаинформации в          -  позволяет прямо на этапе выполнения проверить поддерживает ли объект метод с данным селектором при помощи посылки ему сообщения                                                                                                                            Довольно легко можно послать сообщение  соответствующее данному селектору  без аргументов  с одним  двумя или тремя аргументами   при помощи метода                                                                                                                                                и так далее                                                        Обратите внимание  что методы                  всегда возвращают значение типа     Можно получить класс для данного объекта  послав ему сообщение        Это сообщение возвращает класс в виде указателя на объект типа                                                                                                         С другой стороны также можно легко получить соответствующий              по имени класса                                                     Каждый метод фактически представляет собой функцию с двумя невидимыми аргументами        и       Первый является аналогом       то есть указывает на сам объект   получатель сообщения  Второй   содержит селектор данного метода  Аргумент      может использоваться для посылки сообщений самому себе  как например в следующем методе   -                                                           Однако кроме      есть ещё одна величина  которой могут посылаться сообщения          На самом деле       не является нормальной переменной   это всего лишь ещё одно обозначение для указателя на текущий объект  Но при посылке сообщения       поиск метода начинается не с                текущего объекта  а с                родительского объекта  Таким образом  посылая сообщения       мы тем самым вызываем старые версии методов  переопределенные данным классом  В языке          -  можно по селектору метода получить адрес реализующей его функции  именно как функции языка С   Такая функция отличается от описания метода только вставкой в начало списка аргументов двух дополнительных параметров   указателя на сам объект        и селектора данного метода         Послав объекту сообщение                    мы получаем в ответ адрес реализующей этот метод функции                                                                                                                                                                                                                                                                                                                                               Это позволяет при необходимости многократного вызова одного и того же метода у заданного объекта полностью избежать всех расходов  связанных с пересылкой сообщений   Протоколы править   править код  Язык          -  содержит полноценную поддержку протоколов  это аналог интерфейса в      и абстрактного класса в      который также иногда принято называть интерфейсом   Протокол представляет собой просто список описаний методов  Объект реализует протокол  если он содержит реализации всех методов  описанных в протоколе  Протоколы удобны тем  что позволяют выделять общие черты у разнородных объектов и передавать информацию об объектах заранее неизвестных классов  Простейшее описание протокола выглядит следующим образом                                                    Так  протокол              может быть описан следующим образом                          -                                          -                                                  Протокол может быть унаследован от произвольного количества других протоколов                                                                     Точно так же можно при описании класса задать не только родительский класс  но и набор протоколов                                                                                   Для проверки во время выполнения программы  поддерживается ли объектом заданный протокол объектов  можно использовать сообщение                                                                                                                                 Кроме того  имя протокола  протоколов  можно использовать при описании переменных для явного указания компилятору о поддержке соответствующими объектами протокола  протоколов   Так  если переменная          содержит указатель на объект заранее неизвестного класса  но при этом удовлетворяющий протоколам              и           то её можно описать следующим образом                                          Точно так же  если заранее известно  что          будет содержать указатель на объект  унаследованный от класса       и поддерживающий протокол               то эту переменную можно описать следующим образом                                     Обратите внимание  что подобное описание служит только для сообщения компилятору  какие сообщения поддерживает данный объект  Как и классы  все протоколы в          -  представлены при помощи объектов  класса                                                               Для предварительного объявления протоколов можно использовать следующую конструкцию                                               Эта конструкция сообщает компилятору о том  что                       и          являются именами протоколов  которые будут определены позже   Обработка исключений править   править код  В языке          -  поддерживается обработка исключений  очень похожая на используемую в языках     и       Для этого служат директивы                        и                                                                                                                                                                                                                                                                Для запуска исключения используется директива         в качестве аргумента берущая указатель на объект-исключение  Обычно в                   для этой цели используются объекты класса                                                                        -                            -                                                                       Внутри       -блоков директива        может использоваться без параметра для повторного запуска обрабатываемого исключения                          Синхронизация править   править код  Язык          -  поддерживает синхронизацию для многопоточных приложений  При помощи директивы                  можно защитить фрагмент кода от одновременного выполнения сразу несколькими потоками                   берёт на вход указатель на объект языка          -   можно использовать для этой цели любой объект  в том числе и        который играет роль мьютекса          При попытке потока начать выполнение защищенного фрагмента проверяется  выполняется ли уже этот фрагмент каким-либо потоком  Если да  то сравниваются объекты  переданные этими потоками в                   Если эти указатели совпадают  то поток  пытающийся войти в защищенный блок  будет приостановлен             до тех пор  пока первый поток не выйдет из блока  Тогда выполнение второго потока продолжится  и уже он  запрёт  этот блок для всех остальных потоков  Наличие подобной возможности заметно облегчает жизнь при написании многопоточных приложений  когда необходимо отслеживать попытки одновременного изменения одних и тех же данных сразу несколькими потоками   -                                                                                                                                      В качестве мьютекса  то есть параметра инструкции                рекомендуется указывать объект  недоступный извне  поскольку это может привести к взаимной блокировке  если один и тот же объект используется в качестве мьютекса двумя взаимозависимыми потоками  В частности  не рекомендуется                       Создание и уничтожение объектов править   править код  В самом языке          -  нет специальных команд для создания и уничтожения объектов  подобных     и          Эта задача ложится на        -библиотеку и реализуется при помощи механизма посылки сообщений  Реально используемой и наиболее широко распространенной схемой создания и уничтожения объектов в          -  является используемая в операционных системах          и           которая и будет описана ниже  Создание нового объекта разбивается на два шага   выделение памяти и инициализация объекта  Первый шаг реализуется методом класса        реализованном в классе            который выделяет необходимое количество памяти  данный метод используется для выделения памяти не только для объектов класса           но и любого унаследованного от него класса   При этом в атрибут     записывается указатель на              соответствующего класса  Обратите внимание  что сообщение       посылается             -у требуемого класса и это сообщение возвращает указатель на выделенную под объект память  Собственно сама инициализация объекта  то есть установка значений его         -переменных  выделение дополнительных ресурсов и т  п   осуществляется другими методами  по традиции имена этих методов начинаются с       Обычно такое сообщение посылается сразу же после сообщения       по адресу  возвращенному этим сообщением                                            Приведённая выше конструкция является правильным способом создания объекта  Обратите внимание  что следующая конструкция может в ряде случаев не работать                                                       Это связано с тем  что для ряда классов метод      может вернуть совсем другой указатель  а не        Простейшими примерами того  когда может возникать подобная ситуация  являются синглтоны  тогда  если один экземпляр класса уже существует  то метод      освободит выделенную       ом память и вернет указатель на уже созданный единственный экземпляр  и кэширование объектов  когда для увеличения производительности выделение объектов происходит сразу блоками и объекты не уничтожаются  а сохраняются для переиспользования  При создании нового класса обычно нет необходимости переопределять метод        а вот необходимость переопределения метода      возникает достаточно часто  Обратите внимание  что метод ы       является обычным методом  ничем не выделяющимся среди остальных  в отличие от      где конструктор   это особый метод  у которого  например  нельзя взять адрес   Поэтому при создании нового класса и метода      вызов переопределенного метода       при помощи               должен быть произведен явно в самом начале метода  Довольно часто у объектов бывает сразу несколько методов  начинающихся с       например                                              и т  д  Установившейся практикой в таком случае является выделение среди всех     -методов одного  называемого                         Все остальные     -методы должны вызывать его и только он вызывает унаследованный      метод   -                                                                                                                                                                                                                                   -                                                    В ряде случаев оказывается удобным совместить выделение памяти и инициализацию объекта в один метод  класса   например в классе          есть ряд методов класса  возвращающих уже готовый  проинициализированный  объект                                                                                                                                            как и           для управления временем жизни объектов используют                      каждый объект содержит внутри себя некоторый счетчик  при создании устанавливаемый в единицу  Посылка объекту сообщения        увеличивает значение этого счетчика на единицу  так  все контейнерные классы библиотеки            при помещении в них объекта посылают ему сообщение          Установившейся практикой является посылка объекту сообщения        всеми заинтересованными в нём сторонами  объектами   то есть  если вы запоминаете ссылку на объект  то следует послать ему сообщение         Когда объект перестает быть нужен  ему просто посылается сообщение          Данное сообщение уменьшает значение счетчика на единицу и  если это значение стало меньше единицы  уничтожает данный объект  Перед уничтожением объекта ему посылается сообщение          позволяющее объекту произвести свою деинициализацию  При этом это также является обычным сообщением и в нём вы явно должны в конце вызвать унаследованную реализацию через                   -                                                    Управление памятью править   править код  Базовые принципы править   править код  Управление памятью в          -  базируется на принципе  владения объектом   Основные правила управления памятью в          -  можно записать так   Для получения объекта во владение необходимо вызвать метод  содержащий в названии                либо         Например                                 Для освобождения объекта  который был получен при помощи перечисленных выше функций  необходимо вызвать функцию           либо                Во всех остальных случаях освобождение объекта не требуется  Если полученный объект должен быть сохранен  необходимо либо стать его владельцем  вызвав          либо создать его копию  вызов  содержащий в названии          Данные правила базируются на соглашении по именованию в          -  и  в то же время  сами являются основой этого соглашения   Базовые принципы на практике править   править код  Предположим  в программе существует класс          у которого есть метод                                                                   -                         Рассмотрим небольшой пример использования такого класса                                                                                                                      Так как объект класса         создается явно  он должен быть удален по окончании использования                      В то же время  название метода         не говорит о том  кто должен удалять массив  В такой ситуации считается  что списком работников управляет объект Компания и его удалять не требуется               конструкторы Многие классы позволяют совместить создание объекта с его инициализацией при помощи методов  называемых             конструкторы  такие методы обычно называются             Можно предположить  что вызывающая сторона ответственна за управление временем жизни объекта  но подобное поведение противоречило бы соглашению по именованию в          -                                                              В приведенном коде вызов                   недопустим  так как в данном случае управление временем жизни объекта должно осуществляться при помощи            -пула  Ниже приводится пример корректной реализации метода                                                                                                                    Вернемся к методу         класса          Так как возвращается массив  временем жизни которого вызывающая сторона не управляет  реализация метода         будет выглядеть приблизительно так   -                                                                                                                     Вызов             добавляет объект      в            -пул  вследствие чего возвращаемый объект получит сообщение         при удалении пула  в который он был добавлен  Если объекту  добавленному в            -пул  послать сообщение         самостоятельно  при удалении            -пула возникнет ошибка   Возвращение объекта по ссылке В ряде случаев объекты возвращаются по ссылке  например  метод класса                                              в качестве параметра       принимает                       В этом случае так же работает соглашение по именованию  из которого следует  что явного запроса на владение объектом нет  соответственно  удалять его не требуется   Удаление объектов Когда счетчик ссылок объекта становится равным нулю  объект удаляется  При этом у объекта вызывается метод -               Если в объекте содержатся какие-то данные  их необходимо удалить в этой функции   -                                                               После того  как всем переменным класса было послано сообщение          необходимо вызвать метод         базового класса  Это единственный случай  в котором допустим вызов метода         напрямую  Не существует никаких гарантий относительно времени вызова метода          В ряде случаев он вообще может не вызываться при завершении работы приложения для экономии времени  так как по завершении приложения ОС в любом случае освободит выделенную память  Соответственно  в методе         не должно располагаться никаких методов  отвечающих за закрытие сокетов  файлов и т  п              -пул править   править код             -пул используется для хранения объектов  которым будет послано сообщение         при удалении пула  Для того  чтобы добавить объект в            -пул  ему необходимо отправить сообщение              В приложениях                  -пул всегда доступен по умолчанию  Для не-       приложений необходимо создавать и управлять временем жизни            -пула самостоятельно             -пул реализуется классом                                                                                                                                                                                                                                                          Удалить объекты из            -пула можно не только посредством отправки пулу сообщения          но и с помощью сообщения        Поведение         и       в среде с подсчетом ссылок идентично  Но в случае работы в    среде       вызывает функцию                                     -пул в многопоточной среде В       для каждого из потоков создается свой собственный            -пул  По завершении потока            -пул уничтожается и всем содержащимся в нём объектам посылается сообщение                     -пул главного потока периодически пересоздается с целью уменьшения используемой памяти приложением  Во всех остальных потоках заниматься пересозданием            -пула необходимо самостоятельно  что крайне актуально для долгоживущих потоков   Копирование объектов править   править код  Все объекты в          -  потенциально поддерживают копирование  Для того  чтобы создать копию объекта  необходимо вызвать метод       определённый в классе           Для создания копии будет вызван метод              протокола                     не имеет поддержки этого протокола и при необходимости протокол           должен быть реализован в классах-наследниках  Копии бывают двух видов  поверхностная копия                и полная копия              Разница между этими копиями состоит в том  что при создании поверхностной копии копируются не данные  а ссылка на объект с данными  В случае полной копии копируется объект с данными   Пример реализации Реализация копирования может различаться в зависимости от того  поддерживает ли класс-родитель протокол            Пример кода для ситуации  когда родитель не реализует протокол                                                                                                                  -                                                                                 -                                                                                                                                                      Если родитель поддерживает протокол            реализация будет несколько иной  вызов               заменяется на                                                      Копирование неизменяемых объектов Для           объектов создание копии нецелесообразно  и можно ограничиться отправкой самому себе сообщения          -                                                                Категории править   править код  Язык          -  обладает возможностью добавлять новые методы к уже существующим классам  Аналогичной возможностью обладают языки                      и другие  При этом не требуется исходников класса и добавленные методы автоматически становятся доступными всем классам  унаследованным от изменяемого  Так можно добавить новый метод классу          и этот метод автоматически добавится во все остальные классы  Механизм  позволяющий расширять уже существующие классы  путём добавления новых методов  новые         -переменные добавить таким образом нельзя   называется категорией  Категория имеет своё имя  список методов и имя класса  который она расширяет  Описание категории имеет следующий вид                                                                                            Реализация категории выглядит следующим образом                                                                                              С помощью категорий можно создавать свойства             которые будут доступны только для чтения другим классам и           внутри своего класса                                                                                                                                           Пустая категория                                                                                             -                                               Кроме всего прочего категории можно использовать для того  чтобы обеспечить реализацию классом какого-либо нового протокола  например                          сущности  которые можно распечатать -                                                                  добавляем системному классу          возможность быть распечатанным                                              реализуем новую функциональность -                         Меня распечатали                      Это избавляет от необходимости писать класс-адаптер                 для                          и          -          править   править код  При компиляции программы на языке          -  компилятор для каждого введённого класса автоматически создаёт так называемый                полноценный объект  содержащий в себе всю информацию о данном классе  включая название  суперкласс  список методов и         -переменных  При этом такой объект является полноценным объектом  то есть ему можно посылать сообщения  передавать в качестве параметра  Одной из особенностей              а является поддержка всех методов класса           То есть при отправке сообщения поиск по селектору сначала ведётся среди методов класса  и если метод не найден  поиск продолжается среди         -методов класса           Ещё одной особенностью является возможность инициализации              ов   в начале работы приложения каждому              у посылается сообщение  класса              Это сообщение гарантированно посылается каждому              у  причём всего один раз и до того  как ему будет послано любое другое сообщение  Простейшим примером применения такого сообщения является реализация           ов   именно в методе            следует создать тот самый единственный экземпляр объекта и запомнить его в       -переменной           -          от       содержит большое количество С-функций  служащих для работы с классами  непосредственно во время выполнения программы   Наиболее интересными являются следующие                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Функция                         возвращает указатель на структуру                описывающую заданный         -метод данного класса  Функция                      возвращает указатель на структуру                описывающую заданный метод данного класса  Функция                      возвращает один из списков методов для заданного класса  Приводимый ниже фрагмент кода позволяет перебрать все методы для данного класса                                                                                                                                                                                                                                                                                                                                                                                                                    Функция                  позволяет добавлять новые методы к заданному классу  Функция                     позволяет убирать методы из заданного класса  Функция                             Возвращает количество аргументов для заданного метода  Функция                           возвращает размер места на стеке  занимаемого всеми аргументами данного метода  Функция                        возвращает информацию об одном из аргументов для заданного метода  Функция                           возвращает информацию об         -переменной класса в виде указателя на структуру            Для кодирования информации о типах используется специальное строковое представление  однозначно сопоставляющее каждому типу данных некоторую строку  Явно получить такую строку для произвольного типа можно при помощи конструкции                                                                                                                            Разное править   править код  Официальный сайт            главный источник информации о языке  Форум разработчиков  примеры кода и полная версия документации доступны только зарегистрированным разработчикам              основное средство разработки на языке          -       поддерживает только ОС          и распространяется бесплатно через магазин приложений                  Полезную информации по языку          -  можно найти в     -группе    и архивах списка рассылки     Проект              попытка создания аналогов закрытых библиотек            и         используемых в          и           Исходный код библиотек написан на языке          -  и распространяется свободно  На сайте проекта доступны примеры использования языка и исходный код нескольких приложений           -  доступен практически в каждом дистрибутиве           благодаря компилятору        созданному проектом      Для работы с          -  под ОС         используют эмуляторы среды        бесплатные                   сервисы                   для       См  также править   править код  Си           Примечания править   править код                                                                                                                                                                -                             неопр                                                                                        Дата обращения     декабря       Архивировано    ноября      года                       неопр    Дата обращения     сентября       Архивировано    февраля      года                        -    неопр    Дата обращения     июня       Архивировано    ноября      года         -           неопр    Дата обращения     декабря       Архивировано из оригинала    декабря      года     Официальный сайт проекта           неопр    Дата обращения     мая       Архивировано    января      года    Литература править   править код  Мэтт Нойбург  Программирование для        Основы          -         и                                                  -                              М    Вильямс               с            - -    -    -   Скотт Кнастер  Вакар Малик  Марк Далримпл           -  и программирование для          и       -е издание                  -                                               М    Вильямс               с            - -    -    -   Майкл Приват  Роберт Уорнер  Разработка приложений для                Программирование на          -  в                                                     М   Вильямс              с            - -    -    -   Ссылки править   править код  Ресурсы Форум Стивена Кохана  посвященный          -       англ   Мост для работы с          -  из среды выполнения                        Статьи                              -                                                           англ   Изучаем          -   Букварь  рус   Язык программирования          -   рус                                      -   англ              -                  англ                         -           англ            -                       англ   и перевод  рус                                             -   англ                                      англ     Языки программирования История Хронология     Ада Алгол Ассемблер     Бейсик Си                 Кобол           Форт Фортран                                                Лисп            Оберон          -        Паскаль                                                                                           Категория  Списки  хронологический по категориям  Язык программирования Си            и                                                Компиляторы                                                                                                Библиотеки Стандартная библиотека языка Си                                                 Особенности Операторы  -строка Синтаксис Препроцессор Заголовочные файлы           Типы данных Функции Некоторые потомки      --               -                                      и другие языки   и      Совместимость Операторы  Сравнение        и       Компилятор   в байт-код       Категория Язык программирования Си     Источник                                                       -                  Категории  Языки программирования по алфавитуЯзыки программирования  появившиеся в      годуЯзыки программирования семейства СиОбъектно-ориентированные языки программированияЯзыки с динамической типизациейСвободные компиляторы и интерпретаторыПрограммное обеспечение                 Скрытые категории  Страницы  использующие устаревший тег       Википедия           не указан язык Википедия Статьи с источниками из ВикиданныхПРО ИТ Статьи по алфавитуПРО ИТ Последняя правка  в прошлом годуСтраницы  использующие волшебные ссылки         Навигация    Персональные инструменты    Вы не представились системеОбсуждениеВкладСоздать учётную записьВойти       Пространства имён    СтатьяОбсуждение       русский           Просмотры    ЧитатьТекущая версияПравитьПравить кодИстория       Ещё        Поиск                  Навигация    Заглавная страницаСодержаниеИзбранные статьиСлучайная статьяТекущие событияПожертвовать      Участие    Сообщить об ошибкеКак править статьиСообществоФорумСвежие правкиНовые страницыСправка      Инструменты    Ссылки сюдаСвязанные правкиСлужебные страницыПостоянная ссылкаСведения о страницеЦитировать страницуПолучить короткий    Скачать   -кодЭлемент Викиданных      Печать экспорт    Скачать как    Версия для печати      В других проектах    Викисклад      На других языках                       БеларускаяБългарски                                                                                                                          аза ша   Кыргызча                                                                              Српски                     То ик          Укра нська               -   -      Править ссылки        Эта страница в последний раз была отредактирована    декабря      в        Текст доступен по лицензии                   С указанием авторства   С сохранением условий        -     в отдельных случаях могут действовать дополнительные условия  Подробнее см  Условия использования               зарегистрированный товарный знак некоммерческой организации Фонд Викимедиа                                Политика конфиденциальности Описание Википедии Отказ от ответственности Свяжитесь с нами Кодекс поведения Разработчики Статистика Заявление о куки Мобильная версия          